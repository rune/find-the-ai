/*
Copyright (c) 2024 Rune AI Inc.
All rights reserved.

This code is proprietary to Rune AI Inc.
The code may be used solely for accessing the Service provided by Rune AI Inc. following the Rune AI Inc. Terms of Service ("Terms") accessible at rune.ai/eula. You may not use this code for any use or purpose other than as expressly permitted by the Terms.
Restrictions set forth in the Terms include, but is not limited to, that you may not copy, adapt, modify, prepare derivative works based upon, distribute, license, sell, transfer, publicly display, publicly perform, transmit, stream, broadcast, attempt to discover any source code, reverse engineer, decompile, dissemble, or otherwise exploit the code as a whole or any portion of the code.
*/
type PersistedPlayers<PersistedData> = Record<PlayerId, PersistedData>;
type GameStateWithPersisted<GameState, PersistedData> = GameState & {
    persisted: PersistedPlayers<PersistedData>;
};
type UntypedInitLogicAction = (params?: any) => void;
type UntypedInitLogicActions = Record<string, UntypedInitLogicAction>;
type PlayerId = string;
type Player = {
    playerId: PlayerId;
    displayName: string;
    avatarUrl: string;
};
type Players = Record<PlayerId, Player>;
type Base64Png = string;

type AIPromptResponse = {
    requestId: string;
    response: string;
};
type AIPromptMessageContent = {
    type: "text";
    text: string;
} | {
    type: "image_data";
    image_url: string;
};
type AIPromptRequestData = {
    messages: {
        role: string;
        content: string | AIPromptMessageContent[];
    }[];
};
type AIPromptRequestFunction = (data: AIPromptRequestData) => {
    requestId: string;
};

type ContextWithGameState<Context, GameState, PersistedData> = Context & {
    game: PersistedData extends false ? GameState : GameStateWithPersisted<GameState, PersistedData>;
};
type EventContext = {
    allPlayerIds: PlayerId[];
};
type UpdateContext = {
    allPlayerIds: PlayerId[];
};
type ActionContext = {
    playerId: PlayerId;
    allPlayerIds: PlayerId[];
};
type InitLogicAIResponse<GameState, PersistedData> = (responseData: AIPromptResponse, eventContext: ContextWithGameState<EventContext, GameState, PersistedData>) => void;
type InitLogicEvent<GameState, PersistedData> = (playerId: PlayerId, eventContext: ContextWithGameState<EventContext, GameState, PersistedData>) => void;
type InitLogicEvents<GameState, PersistedData> = {
    playerJoined?: InitLogicEvent<GameState, PersistedData>;
    playerLeft?: InitLogicEvent<GameState, PersistedData>;
};
type InitLogicUpdate<GameState, PersistedData> = (updateContext: ContextWithGameState<UpdateContext, GameState, PersistedData>) => void;
type InitLogicActions<GameState, GameActions extends UntypedInitLogicActions, PersistedData> = {
    [key in keyof GameActions]: (params: Parameters<GameActions[key]>[0], actionContext: ContextWithGameState<ActionContext, GameState, PersistedData>) => void;
};
type InitLogicParams<GameState, GameActions extends UntypedInitLogicActions, PersistedData> = {
    minPlayers: number;
    maxPlayers: number;
    landscape?: boolean;
    updatesPerSecond?: number;
    setup: (allPlayerIds: PlayerId[], context: PersistedData extends false ? undefined : {
        game: {
            persisted: PersistedPlayers<PersistedData>;
        };
    }) => GameState;
    actions: InitLogicActions<GameState, GameActions, PersistedData>;
    events?: InitLogicEvents<GameState, PersistedData>;
    update?: InitLogicUpdate<GameState, PersistedData>;
    inputDelay?: number;
    reactive?: boolean;
    ai?: {
        promptResponse: InitLogicAIResponse<GameState, PersistedData>;
    };
} & (PersistedData extends false ? {
    persistPlayerData?: false;
} : {
    persistPlayerData: true;
});
type SharedSdk<GameState, GameActions extends UntypedInitLogicActions, PersistedData> = {
    initLogic: (params: InitLogicParams<GameState, GameActions, PersistedData>) => void;
    invalidAction: () => Error;
    gameOver: (options?: GameOverOptions) => void;
    /** @deprecated, use gameTime() */
    gameTimeInSeconds: () => number;
    gameTime: () => number;
    worldTime: () => number;
    ai: {
        promptRequest: AIPromptRequestFunction;
    };
};

type OnChangeAction<GameActions extends UntypedInitLogicActions> = {
    [Key in keyof GameActions]: {
        action?: Key;
        name: Key;
        playerId: PlayerId;
        params: Parameters<GameActions[Key]>[0];
    };
}[keyof GameActions];
type OnChangeStateSyncEvent = {
    event: "stateSync";
    isNewGame: boolean;
};
type OnChangePlayerJoinedEvent = {
    event: "playerJoined";
    params: {
        playerId: PlayerId;
    };
};
type OnChangePlayerLeftEvent = {
    event: "playerLeft";
    params: {
        playerId: PlayerId;
    };
};
type OnChangeAIPromptResponseEvent = {
    event: "aiPromptResponse";
    params: {
        requestId: string;
        response: any;
    };
};
type OnChangeTimeSyncEvent = {
    event: "timeSync";
};
type OnChangeUpdateEvent = {
    event: "update";
};
type NameAndEvent<T, N> = Omit<T, "event"> & {
    name: N;
    /** @deprecated Use .name instead of .event */
    event?: N;
};
type OnChangeEvent = NameAndEvent<OnChangeStateSyncEvent, "stateSync"> | NameAndEvent<OnChangePlayerJoinedEvent, "playerJoined"> | NameAndEvent<OnChangePlayerLeftEvent, "playerLeft"> | NameAndEvent<OnChangeTimeSyncEvent, "timeSync"> | NameAndEvent<OnChangeUpdateEvent, "update"> | NameAndEvent<OnChangeAIPromptResponseEvent, "aiPromptResponse">;

type InterpolatorFactory = <Dimensions extends number | number[]>() => Interpolator<Dimensions>;
type Interpolator<Dimensions extends number | number[]> = {
    update: (params: {
        game: Dimensions;
        futureGame: Dimensions;
    }) => void;
    getPosition: () => Dimensions;
};
type InterpolatorLatencyFactory = <Dimensions extends number | number[]>(config: {
    maxSpeed: number;
    timeToMaxSpeed?: number;
}) => InterpolatorLatency<Dimensions>;
type InterpolatorLatency<Dimensions extends number | number[]> = {
    update: (params: {
        game: Dimensions;
        futureGame: Dimensions;
    }) => void;
    getPosition: () => Dimensions;
    jump: (game: Dimensions) => void;
};

type OnChangeParams<GameState, GameActions extends UntypedInitLogicActions, PersistedData = false> = {
    game: PersistedData extends false ? GameState : GameStateWithPersisted<GameState, PersistedData>;
    action?: OnChangeAction<GameActions>;
    event?: OnChangeEvent;
    yourPlayerId: PlayerId | undefined;
    allPlayerIds: PlayerId[];
    rollbacks: OnChangeAction<GameActions>[];
    previousGame: PersistedData extends false ? GameState : GameStateWithPersisted<GameState, PersistedData>;
    futureGame?: PersistedData extends false ? GameState : GameStateWithPersisted<GameState, PersistedData>;
    /** @deprecated Use allPlayerIds in combination with getPlayerInfo()  */
    players: Players;
};
type OnChange<GameState, GameActions extends UntypedInitLogicActions, PersistedData = false> = (params: OnChangeParams<GameState, GameActions, PersistedData>) => void;
type Sdk<GameState, GameActions extends UntypedInitLogicActions, PersistedData> = {
    initClient: (params: {
        onChange: OnChange<GameState, GameActions, PersistedData>;
    }) => void;
    actions: GameActions;
    version: string;
    showGameOverPopUp: () => void;
    showInvitePlayers: () => void;
    showShareImage: (img: Base64Png) => Promise<void>;
    timeSinceLastUpdate: () => number;
    msPerUpdate: number;
    interpolator: InterpolatorFactory;
    interpolatorLatency: InterpolatorLatencyFactory;
    getPlayerInfo: (playerId: PlayerId) => Player;
} & SharedSdk<GameState, GameActions, PersistedData>;
type RuneClient<GameState, GameActions extends UntypedInitLogicActions, PersistedData = false> = Sdk<GameState, GameActions, PersistedData>;
/** @deprecated Please use `npx rune-games-cli@latest dusk-to-rune` or follow migration guide: https://developers.rune.ai/docs/move-to-rune */
type DuskClient<GameState, GameActions extends UntypedInitLogicActions, PersistedData = false> = Sdk<GameState, GameActions, PersistedData>;

type GameOverResult = "WON" | "LOST" | "TIE" | number;
type GameOverOptions = {
    delayPopUp?: boolean;
    minimizePopUp?: boolean;
} & ({
    players: {
        [playerId: PlayerId]: GameOverResult;
    };
    everyone?: never;
} | {
    players?: never;
    everyone: GameOverResult;
});

declare const _default: null;

export { DuskClient, GameOverOptions, GameOverResult, GameStateWithPersisted, Interpolator, InterpolatorLatency, OnChange, OnChangeParams, PersistedPlayers, Player, PlayerId, Players, RuneClient, _default as default };
